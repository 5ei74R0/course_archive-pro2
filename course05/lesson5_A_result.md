## Q 5.1
  ### result
  ```stdout
  Parent() called
  Parent() called
  Parent() called
  Parent(int x = 1) called
  ```

  ### explanation
  - 継承とシグニチャによって結果が生じている。
  - 1行目は`super()`によって親クラス`Parent`の引数無しコンストラクタを呼び出している。
  - 2行目は`super()`を明記していないため、暗黙で親クラス`Parent`の引数無しコンストラクタを呼び出している。
  - 3行目は`super()`によって親クラス`Parent`の引数無しコンストラクタを呼び出している。
  - 4行目は`super(x)`によって親クラス`Parent`の1引数コンストラクタを呼び出している。


## Q 5.2
  ### result
  - 問題文では「A.java, B.java, C.java, User.java の実行結果を示しなさい」
    と書かれているが、`main()`を含むUser.javaの実行結果を以下に示す。
  ```stdout
  1)A:m1 A:m2 A:m3 
  2)B:m1 A:m2 A:m3 
  3)C:m1 A:m2 C:m3 
  4)C:m1 A:m2 C:m3 
  ```

  ### explanation
  - まず継承関係は A <- B <- C <- User となっている。
  - 1行目は`A`のインスタンスのメソッドが呼ばれている。
  - 2行目は`B`のインスタンスのメソッドが呼ばれている。なお、ここでオーバーライドされている
    のは`m1`のみで、`m2`はそのまま`A.m2`を呼び出し、`m3`も`A.m3`が呼び出される。
  - 3行目は`C`のインスタンスのメソッドが呼ばれている。Cは`m1`と`m3`をオーバーライド
    している。そして`m2`は`B.m2`を呼び出し、`B.m2`は`A.m2`を呼び出すので結果的に`A.m2`が呼ばれる。
  - 4行目は`User`のインスタンスのメソッドが呼ばれている。`User`では特にオーバーライドをしていないので、
    `C`のメソッドがそのまま呼ばれ、3行目と同様の出力となる。


## Q 5.3
  ### explanation
  - `class Prob53 extends X`の中で、抽象クラス`abstract class X`で定義されている
    抽象メソッド`abstract void methodX()`のオーバーライドをしていないため、コンパイルが通らない。

## Q 5.4
  ### explanation
  - `Y y = new X();`がおかしい。YはXの子クラスである。
    子クラスのオブジェクトは親クラスに自動的に型変換されるが、その逆は出来ない。
    つまり逆に`X x = new Y();`はOK
